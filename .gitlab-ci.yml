# Includes: SAST, Secret Detection, Container Scanning
include:
  - template: Security/SAST.gitlab-ci.yml            # Python SAST (Bandit/Semgrep)
  - template: Security/Secret-Detection.gitlab-ci.yml # Secret scanning (Gitleaks)
  - template: Jobs/Container-Scanning.gitlab-ci.yml   # Trivy-based container scanning

stages:
  - test
  - build
  - scan
  - deploy

# ---------- Global settings ----------
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.pip-cache"
  DOCKER_DRIVER: overlay2
  DOCKER_BUILDKIT: "1"     # Faster Docker builds

cache:
  key: "pip-cache"
  paths:
    - .pip-cache/

# ---------- 1) TEST ----------
unit_tests:
  stage: test
  image: python:3.12-slim
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  before_script:
    - python -m pip install --upgrade pip
    - pip install -e "ids_iforest_package[test]"
  script:
    - cd ids_iforest_package
    # Write coverage to repo root so artifact paths are stable
    - pytest -q --cov=ids_iforest --cov-report=xml:../coverage.xml --cov-report=html:../htmlcov
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.xml
      - htmlcov/
    expire_in: 1 week

# ---------- Reusable anchor for Docker build jobs ----------
.docker-build: &docker_build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_TAG'
  retry:
    max: 2
    when:
      - runner_system_failure
      - scheduler_failure
      - data_integrity_failure

# ---------- 2) BUILD ----------
# attacker: context services/attacker
build_attacker:
  <<: *docker_build
  stage: build
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}" services/attacker
    # main convenience tag
    - if [ -z "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/attacker:latest"; fi
    - docker push "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}"
    - if [ -z "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/attacker:latest"; fi
    # release tag
    - if [ -n "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_TAG}"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_TAG}"; fi

# ids: Dockerfile uses repo-root context (per docker-compose)
build_ids:
  <<: *docker_build
  stage: build
  script:
    - docker build --pull -f services/ids/Dockerfile -t "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}" .
    - if [ -z "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/ids:latest"; fi
    - docker push "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}"
    - if [ -z "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/ids:latest"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_TAG}"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_TAG}"; fi

# web: context services/web
build_web:
  <<: *docker_build
  stage: build
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}" services/web
    - if [ -z "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/web:latest"; fi
    - docker push "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}"
    - if [ -z "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/web:latest"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_TAG}"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_TAG}"; fi

# ---------- 3) SCAN ----------
# Disable the default template job so it doesn't scan $CI_REGISTRY_IMAGE/main:$CI_COMMIT_SHA
container_scanning:
  rules:
    - when: never

# Base for our three image scans; inherits analyzer and sets artifacts cleanly.
.container-scan-base:
  extends: container_scanning
  stage: scan
  needs: []
  retry:
    max: 2
    when:
      - runner_system_failure
      - scheduler_failure
      - data_integrity_failure
  allow_failure: true         # keep pipeline green even with findings (as requested)
  variables:
    CS_DISABLE_LANGUAGE_VULNERABILITY_SCAN: "false"   # include Python packages found in images
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
      cyclonedx: "**/gl-sbom-*.cdx.json"
    paths:
      - gl-container-scanning-report.json
      - "**/gl-sbom-*.cdx.json"

# Each job scans a concrete image:tag that we built and pushed above.
container_scan_attacker:
  extends: .container-scan-base
  needs: [build_attacker]
  rules:
    - if: '$CI_COMMIT_TAG'
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/attacker:$CI_COMMIT_TAG"
    - if: '$CI_COMMIT_BRANCH == "main"'
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/attacker:$CI_COMMIT_SHORT_SHA"
  variables:
    GIT_STRATEGY: fetch
    CS_DOCKERFILE_PATH: "services/attacker/Dockerfile"

container_scan_ids:
  extends: .container-scan-base
  needs: [build_ids]
  rules:
    - if: '$CI_COMMIT_TAG'
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/ids:$CI_COMMIT_TAG"
    - if: '$CI_COMMIT_BRANCH == "main"'
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/ids:$CI_COMMIT_SHORT_SHA"
  variables:
    GIT_STRATEGY: fetch
    CS_DOCKERFILE_PATH: "services/ids/Dockerfile"

container_scan_web:
  extends: .container-scan-base
  needs: [build_web]
  rules:
    - if: '$CI_COMMIT_TAG'
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/web:$CI_COMMIT_TAG"
    - if: '$CI_COMMIT_BRANCH == "main"'
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/web:$CI_COMMIT_SHORT_SHA"
  variables:
    GIT_STRATEGY: fetch
    CS_DOCKERFILE_PATH: "services/web/Dockerfile"

# Python dependency audit (non-blocking) with downloadable JSON
dependency_scan:
  stage: scan
  image: python:3.12-slim
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  before_script:
    - python -m pip install --upgrade pip
    - pip install pip-audit
    - pip install -e ids_iforest_package/
  script:
    - pip-audit -f json -o pip-audit.json || true
  allow_failure: true
  artifacts:
    paths:
      - pip-audit.json
    expire_in: 1 week

# ---------- 2b) BUILD (PyPI dists) ----------
build_pypi_dist:
  stage: build
  image: python:3.12-slim
  # Build only for releases (tags)
  rules:
    - if: '$CI_COMMIT_TAG'
  before_script:
    - python -m pip install -U pip build
  script:
    - cd ids_iforest_package
    - python -m build           # creates ./dist/ (wheel + sdist)
  artifacts:
    paths:
      - ids_iforest_package/dist/
    expire_in: 1 week


publish_to_pypi:
  stage: deploy
  image: python:3.12-slim
  # Fetch the wheel/sdist built above
  dependencies:
    - build_pypi_dist
  # Publish only from immutable releases (tags)
  rules:
    - if: '$CI_COMMIT_TAG'
  # Request an OIDC ID token from GitLab for PyPI
  id_tokens:
    PYPI_ID_TOKEN:
      aud: pypi        # use 'testpypi' if targeting TestPyPI
  # Optional but recommended: tie to a protected environment
  environment:
    name: release
  variables:
    PIP_DISABLE_PIP_VERSION_CHECK: "1"
    TWINE_NON_INTERACTIVE: "1"
  before_script:
    - python -m pip install -U pip twine
  script:
    - twine check --strict ids_iforest_package/dist/*
    # With Trusted Publishing, Twine exchanges the OIDC token automatically:
    - twine upload ids_iforest_package/dist/*

# Publish HTML coverage via GitLab Pages (browse without downloading)
pages:
  stage: deploy
  dependencies:
    - unit_tests
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - mv htmlcov public
  artifacts:
    paths:
      - public
    expire_in: 30 days
