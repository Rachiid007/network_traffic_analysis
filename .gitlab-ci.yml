# Includes: SAST, Secret Detection, Container Scanning
include:
  - template: Security/SAST.gitlab-ci.yml # Static code analysis (Bandit/Semgrep for Python)
  - template: Security/Secret-Detection.gitlab-ci.yml # Secret scanning (Gitleaks)
  - template: Jobs/Container-Scanning.gitlab-ci.yml # Container vulnerability scanning
# Optionally include Dependency Scanning template:
#  - template: Security/Dependency-Scanning.gitlab-ci.yml

stages:
  - test
  - build
  - scan
  - deploy

# ---------- Global settings ----------
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.pip-cache"
  DOCKER_DRIVER: overlay2
  DOCKER_BUILDKIT: 1 # Enable Docker BuildKit for faster caching
  # CS_DISABLE_LANGUAGE_VULNERABILITY_SCAN, CS_DOCKERFILE_PATH, etc., will be set in the container_scanning job.

cache:
  key: "pip-cache"
  paths:
    - .pip-cache/

# ---------- 1) TEST ----------
unit_tests:
  stage: test
  image: python:3.12-slim
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  before_script:
    - python -m pip install --upgrade pip
    - pip install -e "ids_iforest_package[test]"
  script:
    - cd ids_iforest_package
    # Write coverage to project root so artifact paths are stable
    - pytest -q --cov=ids_iforest --cov-report=xml:../coverage.xml --cov-report=html:../htmlcov
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml # Cobertura XML for GitLab coverage visualization
    paths:
      - coverage.xml
      - htmlcov/ # HTML coverage report (to be downloadable or published)
    expire_in: 1 week

# ---------- Reusable anchor for Docker build jobs ----------
.docker-build: &docker_build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  # Build on main and on tags (so release tags also build/push images)
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_TAG'

# ---------- 2) BUILD ----------
# attacker: context services/attacker
build_attacker:
  <<: *docker_build
  stage: build
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}" services/attacker
    # main convenience tag
    - if [ -z "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/attacker:latest"; fi
    - docker push "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}"
    - if [ -z "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/attacker:latest"; fi
    # release tag
    - if [ -n "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_TAG}"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_TAG}"; fi

# ids: Dockerfile uses repo-root context (per docker-compose)
build_ids:
  <<: *docker_build
  stage: build
  script:
    - docker build --pull -f services/ids/Dockerfile -t "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}" .
    - if [ -z "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/ids:latest"; fi
    - docker push "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}"
    - if [ -z "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/ids:latest"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_TAG}"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_TAG}"; fi

# web: context services/web
build_web:
  <<: *docker_build
  stage: build
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}" services/web
    - if [ -z "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/web:latest"; fi
    - docker push "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}"
    - if [ -z "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/web:latest"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker tag "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}" "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_TAG}"; fi
    - if [ -n "$CI_COMMIT_TAG" ]; then docker push "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_TAG}"; fi

# ---------- 3) SCAN ----------
# Python dependency scan (non-blocking) with downloadable JSON
dependency_scan:
  stage: scan
  image: python:3.12-slim
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  before_script:
    - python -m pip install --upgrade pip
    - pip install pip-audit
    - pip install -e ids_iforest_package/
  script:
    # Make job *green* even if vulns exist, but keep a machine-readable artifact
    - pip-audit -f json -o pip-audit.json || true
  allow_failure: true
  artifacts:
    paths:
      - pip-audit.json
    expire_in: 1 week

# Use THREE explicit jobs instead of a matrix so CS_IMAGE is a concrete value.
# Each job EXTENDS the official template's 'container_scanning' job.
container_scan_attacker:
  extends: container_scanning
  stage: scan
  needs: [build_attacker]
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/attacker:$CI_COMMIT_TAG"
    - if: $CI_COMMIT_BRANCH == "main"
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/attacker:$CI_COMMIT_SHORT_SHA"
  variables:
    CS_DISABLE_LANGUAGE_VULNERABILITY_SCAN: "false"
  allow_failure: true

container_scan_ids:
  extends: container_scanning
  stage: scan
  needs: [build_ids]
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/ids:$CI_COMMIT_TAG"
    - if: $CI_COMMIT_BRANCH == "main"
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/ids:$CI_COMMIT_SHORT_SHA"
  variables:
    CS_DISABLE_LANGUAGE_VULNERABILITY_SCAN: "false"
    # Uncomment the next two lines if you want remediation hints (requires repo checkout)
    # GIT_STRATEGY: fetch
    # CS_DOCKERFILE_PATH: "services/ids/Dockerfile"
  allow_failure: true

container_scan_web:
  extends: container_scanning
  stage: scan
  needs: [build_web]
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/web:$CI_COMMIT_TAG"
    - if: $CI_COMMIT_BRANCH == "main"
      variables:
        CS_IMAGE: "$CI_REGISTRY_IMAGE/web:$CI_COMMIT_SHORT_SHA"
  variables:
    CS_DISABLE_LANGUAGE_VULNERABILITY_SCAN: "false"
  allow_failure: true

# ---------- 4) DEPLOY ----------
publish_to_pypi:
  stage: deploy
  image: python:3.12-slim
  rules:
    - if: "$CI_COMMIT_TAG"
  variables:
    PIP_DISABLE_PIP_VERSION_CHECK: "1"
  before_script:
    - python -m pip install --upgrade pip
    - pip install build twine
  script:
    - cd ids_iforest_package
    - python -m build
    - twine upload dist/* -u "$PYPI_USERNAME" -p "$PYPI_PASSWORD"

# Publish HTML coverage via GitLab Pages (browse without downloading)
pages:
  stage: deploy
  dependencies:
    - unit_tests
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - mv htmlcov public
  artifacts:
    paths:
      - public
    expire_in: 30 days
