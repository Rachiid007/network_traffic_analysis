# Include GitLab's security scanning templates for SAST (static code analysis) and secret detection
include:
  - template: Security/SAST.gitlab-ci.yml             # Enables Bandit, Semgrep, etc. for Python code
  - template: Security/Secret-Detection.gitlab-ci.yml # Enables secret leak scanning with Gitleaks

stages:
  - test     # run tests and code analysis
  - build    # build docker images for each service
  - scan     # security scans (dependencies and container images)
  - deploy   # deploy/release (e.g., publish to PyPI)

# 1. Test Stage
unit_tests:
  stage: test
  image: python:3.10
  before_script:
    - python -m pip install --upgrade pip wheel setuptools
    # Install with binary dependencies to avoid compilation issues
    - pip install --only-binary=numpy,scipy,pandas -e "ids_iforest_package/[test]"
    # Install tshark (wireshark-cli) for more thorough testing if needed
    - apt-get update -y && apt-get install -y tshark
  script:
    # Run tests with pytest
    - cd ids_iforest_package && python -m pytest -v -xvs
    # Run tests with coverage
    - python -m pytest -xvs --cov=ids_iforest --cov-report=xml --cov-report=term
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.xml
    expire_in: 1 week

# (Note: SAST and Secret Detection jobs are automatically added by the include templates above.
# They will run in this stage as well, scanning the code for vulnerabilities and secrets.)

# 2. Build Stage – one job per service container
build_attacker:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  script:
    # Authenticate to GitLab Container Registry
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" --password-stdin
    # Build and push the "attacker" service image
    - docker build -t "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}" services/attacker
    - docker push "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}"
  only:
    - branches   # run on all branch commits

build_ids:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" --password-stdin
    # Build and push the "ids" service image
    - docker build -t "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}" services/ids
    - docker push "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}"
  only:
    - branches

build_web:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" --password-stdin
    # Build and push the "web" service image
    - docker build -t "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}" services/web
    - docker push "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}"
  only:
    - branches

# 3. Scan Stage – security scanning jobs
dependency_scan:
  stage: scan
  image: python:3.10
  allow_failure: false    # fail the job if vulnerabilities are found
  before_script:
    - pip install --upgrade pip
    - pip install pip-audit           # install pip-audit tool for dependency scanning
    - pip install -e ids_iforest_package/   # install the package to capture all its dependencies
  script:
    - pip-audit    # scan installed dependencies for known vulnerabilities
  # (pip-audit will exit non-zero if any vulnerable dependencies are found)

scan_images:
  stage: scan
  image: aquasec/trivy:latest
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  allow_failure: false
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" --password-stdin
    # Loop through each service directory and scan its image (skip if no Dockerfile)
    - |
      for service_dir in $(ls services); do
        if [ -f "services/$service_dir/Dockerfile" ]; then
          echo "Scanning image for $service_dir..."
          docker pull "$CI_REGISTRY_IMAGE/${service_dir}:${CI_COMMIT_SHORT_SHA}" || exit $?
          # Fail the job if any HIGH or CRITICAL vulnerabilities are found
          trivy image --exit-code 1 --severity HIGH,CRITICAL "$CI_REGISTRY_IMAGE/${service_dir}:${CI_COMMIT_SHORT_SHA}" || exit $?
        else
          echo "Skipping $service_dir (no Dockerfile present; no image to scan)."
        fi
      done

# 4. Deploy Stage – publish package to PyPI (runs on tagged commits)
publish_to_pypi:
  stage: deploy
  image: python:3.10
  variables:
    PIP_DISABLE_PIP_VERSION_CHECK: "1"
  before_script:
    - pip install --upgrade pip
    - pip install build twine    # install build tools for packaging
  script:
    - python -m build ids_iforest_package/         # build the package (creates dist/*.whl and dist/*.tar.gz)
    - twine upload dist/* -u "$PYPI_USERNAME" -p "$PYPI_PASSWORD"  # upload to PyPI
  only:
    - tags       # only run on Git tags (so that every code push doesn't publish)
