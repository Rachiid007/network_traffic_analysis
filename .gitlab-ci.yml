# Security analyzers
include:
  - template: Security/SAST.gitlab-ci.yml             # Bandit/Semgrep for Python
  - template: Security/Secret-Detection.gitlab-ci.yml # Gitleaks-style secret scanning

stages:
  - test
  - build
  - scan
  - deploy

# ---------- Global settings ----------
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.pip-cache"
  DOCKER_DRIVER: overlay2

cache:
  key: "pip-cache"
  paths:
    - .pip-cache/

# ---------- 1) TEST ----------
unit_tests:
  stage: test
  image: python:3.12-slim
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  before_script:
    - python -m pip install --upgrade pip
    # Install your package in editable mode with test extras (pytest, pytest-cov, etc.)
    - pip install -e "ids_iforest_package[test]"
  script:
    - cd ids_iforest_package
    # pytest options are already in pyproject; add HTML coverage output explicitly
    - pytest -q --cov-report=xml --cov-report=html
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: ids_iforest_package/coverage.xml
    paths:
      - ids_iforest_package/coverage.xml
      - ids_iforest_package/htmlcov/
    expire_in: 1 week

# NOTE:
# SAST + Secret Detection jobs from the templates run in the "test" stage automatically.

# ---------- Reusable anchor for docker build jobs ----------
.docker-build-template: &docker_build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    # Auth to GitLab Container Registry using built-in CI variables
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# ---------- 2) BUILD ----------
# attacker: context is ./services/attacker (Dockerfile lives there)
build_attacker:
  stage: build
  <<: *docker_build
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}" services/attacker
    - docker push "$CI_REGISTRY_IMAGE/attacker:${CI_COMMIT_SHORT_SHA}"

# ids: Dockerfile expects repo-root context (see docker-compose.yml)
# so we build from '.' and point to Dockerfile explicitly
build_ids:
  stage: build
  <<: *docker_build
  script:
    - docker build --pull -f services/ids/Dockerfile -t "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}" .
    - docker push "$CI_REGISTRY_IMAGE/ids:${CI_COMMIT_SHORT_SHA}"

# web: context is ./services/web (Dockerfile lives there)
build_web:
  stage: build
  <<: *docker_build
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}" services/web
    - docker push "$CI_REGISTRY_IMAGE/web:${CI_COMMIT_SHORT_SHA}"

# ---------- 3) SCAN (DevSecOps) ----------
# Dependency vulnerability scan for the Python package
dependency_scan:
  stage: scan
  image: python:3.12-slim
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  before_script:
    - python -m pip install --upgrade pip
    - pip install pip-audit
    - pip install -e ids_iforest_package/
  script:
    - pip-audit
  allow_failure: true  # set to false to enforce

# Container image scanning with Trivy for each built image (no docker daemon needed)
scan_images:
  stage: scan
  image: aquasec/trivy:latest
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  variables:
    # Trivy uses these for private registries
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
  script:
    - >
      for s in attacker ids web; do
        echo "Scanning $CI_REGISTRY_IMAGE/$s:${CI_COMMIT_SHORT_SHA}";
        trivy image --quiet --no-progress --ignore-unfixed
        --exit-code 1 --severity HIGH,CRITICAL
        "$CI_REGISTRY_IMAGE/$s:${CI_COMMIT_SHORT_SHA}";
      done
  allow_failure: true  # set to false to enforce

# ---------- 4) DEPLOY (PyPI) ----------
# Publishes the Python package when you push a tag
publish_to_pypi:
  stage: deploy
  image: python:3.12-slim
  rules:
    - if: '$CI_COMMIT_TAG'
  variables:
    PIP_DISABLE_PIP_VERSION_CHECK: "1"
  before_script:
    - python -m pip install --upgrade pip
    - pip install build twine
  script:
    - cd ids_iforest_package
    - python -m build
    - twine upload dist/* -u "$PYPI_USERNAME" -p "$PYPI_PASSWORD"
